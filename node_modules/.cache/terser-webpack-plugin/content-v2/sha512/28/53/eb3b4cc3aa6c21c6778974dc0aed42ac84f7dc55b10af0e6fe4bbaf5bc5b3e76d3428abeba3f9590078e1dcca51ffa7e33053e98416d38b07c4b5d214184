{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{345:function(e,a,n){\"use strict\";n.r(a);var t=n(28),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,n=e._self._c||a;return n(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[n(\"h3\",{attrs:{id:\"webpack-优化\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack-优化\"}},[e._v(\"#\")]),e._v(\" webpack 优化\")]),e._v(\" \"),n(\"h3\",{attrs:{id:\"一-缩小文件的搜索范围\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#一-缩小文件的搜索范围\"}},[e._v(\"#\")]),e._v(\" 一.缩小文件的搜索范围\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"_1-resolve字段\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-resolve字段\"}},[e._v(\"#\")]),e._v(\" 1.resolve字段\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[n(\"p\",[e._v(\"设置 resole.modules 避免层层查找。\")]),e._v(\" \"),n(\"p\",[e._v(\"例如：\"),n(\"code\",[e._v(\"[path.resolve(__dirname, 'node_modules')]\")])])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"设置 resolve.alias 直接使用库的min文件\")]),e._v(\" \"),n(\"p\",[e._v(\"例如：\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"  \\n  resolve.alias: {\\n    'react': [path.resolve(__dirname, './node_modules/react/dist/react.min.js')],\\n    '@Component': '../component'\\n  }\\n  \\n\")])])]),n(\"p\",[e._v(\"像第二种，当我们的文件结构很复杂的时候，我们可以使用 import {} from '@Component/...' 来引用我们的组件。\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"配置 resolve.extensions 减少文件查找\")]),e._v(\" \"),n(\"p\",[e._v(\"例如：\"),n(\"code\",[e._v(\"resolve.extensions: ['.js', '.min.js']\")])])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"配置 module.noParse 字段告诉Webpack不必解析那些文件，可以用来排除非模块化库文件的解析。\")])]),e._v(\" \"),n(\"li\",[n(\"p\",[e._v(\"使用loader的时候，可以配置exclude、include缩小搜索范围。\")])])]),e._v(\" \"),n(\"h3\",{attrs:{id:\"二、合理利用缓存\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#二、合理利用缓存\"}},[e._v(\"#\")]),e._v(\" 二、合理利用缓存\")]),e._v(\" \"),n(\"p\",[e._v(\"大部分loader都提供了cache的配置项，比如 babel-loader，我们可以设置 babel-loader?cacheDirectory=true 来开启缓存。也可以用过一个神奇的 cache-loader 将loader的编译结果写入硬盘缓存。这里主要，要写在第一位哦。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\nmodule.exports = {\\n  module: {\\n    rules: [\\n      {\\n        test: /\\\\.less$/,\\n        use: ['cache-loader', ...loaders],\\n        include: path.resolve('src'),\\n      },\\n    ],\\n  },\\n};\\n\\n\")])])]),n(\"p\",[e._v(\"另外压缩阶段也是可以设置缓存的。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\nmodule.exports = {\\n  optimization: {\\n    minimizer: [\\n      new UglifyJsPlugin({\\n        cache: true,\\n        parallel: true,\\n      }),\\n    ],\\n  },\\n};\\n\\n\")])])]),n(\"h3\",{attrs:{id:\"三、多进程转换\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#三、多进程转换\"}},[e._v(\"#\")]),e._v(\" 三、多进程转换\")]),e._v(\" \"),n(\"p\",[e._v(\"运行在node上的webpack也不会避免单线程的诅咒，只能一个文件一个文件的进行处理，不能并行处理。不过webpack提供的Happypack可以有效的帮助我们解决这个问题。Happypack可以将任务分解给多个子线程，最终发给主线程。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\nconst HappyPack = require('happypack');\\nconst os = require('os');\\nconst happyThreadPool = HappyPack.ThreadPool({ size: os.cpus().length });\\n\\nmodule.export = {\\n...\\n\\n  plugins: [\\n    new HappyPack({\\n      id: 'babel',\\n      loaders: [{\\n        loader: 'babel-loader',\\n        options: {\\n          presets: ['@babel/preset-env', '@babel/preset-react']\\n        }\\n      }],\\n      threadPool: happyThreadPool\\n    }),\\n    new HappyPack({\\n      id: 'css',\\n      loaders: ['style-loader', 'css-loader'],\\n      threadPool: happyThreadPool\\n    }),\\n  ],\\n  module: {\\n      rules: [\\n          {\\n              test: /\\\\.js$/,\\n              use: ['happypack/loader?id=babel'],\\n              exclude: path.resolve(__dirname, 'node_modules')\\n          },\\n          {\\n              test: /\\\\.css$/,\\n              use: ['happypack/loader?id=css']\\n          }\\n      ]\\n  }\\n}\\n\\n\")])])]),n(\"h3\",{attrs:{id:\"四、文件压缩\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#四、文件压缩\"}},[e._v(\"#\")]),e._v(\" 四、文件压缩\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"_1-webpack自带压缩方式\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-webpack自带压缩方式\"}},[e._v(\"#\")]),e._v(\" 1.webpack自带压缩方式\")]),e._v(\" \"),n(\"p\",[n(\"code\",[e._v(\"new UglifyJsPlugin()\")]),e._v(\", 具体参数，移步官网 \"),n(\"a\",{attrs:{href:\"https://www.webpackjs.com/plugins/uglifyjs-webpack-plugin/\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"地址\"),n(\"OutboundLink\")],1)]),e._v(\" \"),n(\"h4\",{attrs:{id:\"_2-多进程压缩文件\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-多进程压缩文件\"}},[e._v(\"#\")]),e._v(\" 2.多进程压缩文件\")]),e._v(\" \"),n(\"p\",[e._v(\"传统压缩方式是一个文件一个文件的进行压缩，我们可以使用 ParallelUglifyPlugin 开启多进程压缩。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\nconst ParallelUglifyPlugin = require('wbepack-parallel-uglify-plugin');\\n//...\\nplugins: [\\n    new ParallelUglifyPlugin({\\n        uglifyJS:{\\n            //...这里放uglifyJS的参数\\n        },\\n        //...其他ParallelUglifyPlugin的参数，设置cacheDir可以开启缓存，加快构建速度\\n    })\\n]\\n\\n\")])])]),n(\"h3\",{attrs:{id:\"五、抽离公共资源\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#五、抽离公共资源\"}},[e._v(\"#\")]),e._v(\" 五、抽离公共资源\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"_1-webpack-dll-plugin（不推荐）\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-webpack-dll-plugin（不推荐）\"}},[e._v(\"#\")]),e._v(\" 1.webpack-dll-plugin（不推荐）\")]),e._v(\" \"),n(\"p\",[e._v(\"不推荐原因1： 每次依赖更新需要手动维护\\n不推荐原因2： 将所有资源预编译成一份文件，导致单个文件的体积过大，符合http1.1的标准，可以减少请求数，但是对于http2来说，不容易体现多路复用的优势。\")]),e._v(\" \"),n(\"h4\",{attrs:{id:\"_2-externals\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-externals\"}},[e._v(\"#\")]),e._v(\" 2.externals\")]),e._v(\" \"),n(\"p\",[e._v(\"它的原理其实就是不将我们指定的资源进行打包，而是用过CDN的方式进行引入，减小包的体积，提高构建速度。不过要记得在HTML文件里引入cdn哦。最好使用公司自己的cdn服务，都是泪啊。\")]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v('\\nmodule.exports = {\\n  ...,\\n  externals: {\\n    \"react\": \"React\",\\n    \"react-dom\": \"ReactDOM\",\\n    \"redux\": \"Redux\",\\n    \"react-router-dom\": \"ReactRouterDOM\"\\n  }\\n}\\n\\n')])])]),n(\"h3\",{attrs:{id:\"六、按需加载\"}},[n(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#六、按需加载\"}},[e._v(\"#\")]),e._v(\" 六、按需加载\")]),e._v(\" \"),n(\"p\",[e._v(\"webpack 4 最大的改动就是废除了 CommonsChunkPlugin 引入了 optimization.splitChunks。\")]),e._v(\" \"),n(\"p\",[e._v(\"可以分为五类\")]),e._v(\" \"),n(\"ul\",[n(\"li\",[e._v(\"基础类库 比如 react、react-dom等\")]),e._v(\" \"),n(\"li\",[e._v(\"UI库 antd等\")]),e._v(\" \"),n(\"li\",[e._v(\"低频组件 echarts等\")]),e._v(\" \"),n(\"li\",[e._v(\"公共组件 项目中公共组件\")]),e._v(\" \"),n(\"li\",[e._v(\"业务代码\")])]),e._v(\" \"),n(\"div\",{staticClass:\"language- extra-class\"},[n(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[n(\"code\",[e._v(\"\\noptimization: {\\n  splitChunks: {\\n    chunks: 'all',\\n    cacheGroups: {\\n      libs: {\\n        name: 'chunks-lib',\\n        test: /[\\\\\\\\/]node_modules[\\\\\\\\/]/,\\n        priority: 10,\\n        chunks: 'initial'\\n      },\\n      antd: {\\n        name: 'antd-lib',\\n        test: /[\\\\\\\\/]node_modules[\\\\\\\\/]antd[\\\\\\\\/]/,\\n        priority: 20,\\n        chunks: 'initial'\\n      },\\n      antdDesign: {\\n        name: 'antd-lib',\\n        test: /[\\\\\\\\/]node_modules[\\\\\\\\/]@ant-design[\\\\\\\\/]/,\\n        priority: 20,\\n        chunks: 'initial'\\n      },\\n      echarts: {\\n        name: 'echarts',\\n        test: /[\\\\\\\\/]node_modules[\\\\\\\\/]echarts[\\\\\\\\/]/,\\n        priority: 20,\\n        chunks: 'initial'\\n      }\\n    }\\n  }\\n}\\n\\n\\n\")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);","extractedComments":[]}