{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{287:function(t,e,r){\"use strict\";r.r(e);var s=r(28),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[r(\"h3\",{attrs:{id:\"懒加载\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#懒加载\"}},[t._v(\"#\")]),t._v(\" 懒加载\")]),t._v(\" \"),r(\"h3\",{attrs:{id:\"导读\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[t._v(\"#\")]),t._v(\" 导读\")]),t._v(\" \"),r(\"hr\"),t._v(\" \"),r(\"p\",[t._v(\"相信很多小伙伴在工作中都会遇到图片请求数量过多，导致出现页面会出现卡顿的情况，在我们前端开发工作中，页面的渲染速度是十分重要的。\"),r(\"br\"),t._v(\"\\n谈到这，我们都知道其中最大的一个问题就是\"),r(\"code\",[t._v(\"图片加载速度\")]),t._v(\"会拖累整个页面体验。很多页面，内容很丰富，页面很长，图片较多,比如说各种商城页面。这些页面图片数量多，而且比较大，少说百来K，多则上兆。有的时候没有必要一次性加载完。否则常会出现加载半张图片或是残缺，网速不好的有时候还会出现图片加载不出来等问题。\"),r(\"br\"),t._v(\"那么我们可以使用现有的技术，先显示\"),r(\"code\",[t._v(\"可视区域\")]),t._v(\"中的图片，再使剩余图片未显示的图片和\"),r(\"code\",[t._v(\"滚动条事件\")]),t._v(\"做交互，“滑到你，你再显示出来”，这也就是我们常说的\"),r(\"code\",[t._v(\"懒加载\")]),t._v(\"，来我们看一下关于懒加载的定义。\")]),t._v(\" \"),r(\"blockquote\",[r(\"p\",[r(\"code\",[t._v(\"懒加载\")]),t._v(\"(Load On Demand)是一种独特而又强大的\"),r(\"code\",[t._v(\"数据获取\")]),t._v(\"方法,它能够在用户\"),r(\"code\",[t._v(\"滚动页面\")]),t._v(\"的时候自动获取更多的数据,而新得到的数据不会影响原有数据的显示,同时最大程度上减少服务器端的资源耗用。\")])]),t._v(\" \"),r(\"p\",[t._v(\"关于懒加载的方式有很多种，在这里只会着重介绍其中两种，\"),r(\"code\",[t._v(\"传统的懒加载方式\")]),t._v(\"以及\"),r(\"code\",[t._v(\"交叉观察者\")]),t._v(\"这两种方式。\")]),t._v(\" \"),r(\"h3\",{attrs:{id:\"传统的懒加载方式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#传统的懒加载方式\"}},[t._v(\"#\")]),t._v(\" 传统的懒加载方式\")]),t._v(\" \"),r(\"hr\"),t._v(\" \"),r(\"blockquote\",[r(\"p\",[t._v(\"传统的\"),r(\"code\",[t._v(\"懒加载\")]),t._v(\"方式其实就是通过监听滚动轴的变化，去请求出现在可视区域的图片。\")])]),t._v(\" \"),r(\"h4\",{attrs:{id:\"原理\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#原理\"}},[t._v(\"#\")]),t._v(\" 原理\")]),t._v(\" \"),r(\"blockquote\",[r(\"p\",[t._v(\"将页面中的\"),r(\"code\",[t._v(\"img\")]),t._v(\"标签\"),r(\"code\",[t._v(\"src\")]),t._v(\"指向一张小图片或者\"),r(\"code\",[t._v(\"src\")]),t._v(\"为空，然后定义\"),r(\"code\",[t._v(\"data-src\")]),t._v(\"（这个属性可以自定义命名，我采用\"),r(\"code\",[t._v(\"data-src\")]),t._v(\"）属性指向真实的图片。\\n\"),r(\"br\")])]),t._v(\" \"),r(\"h4\",{attrs:{id:\"新建一个html文件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#新建一个html文件\"}},[t._v(\"#\")]),t._v(\" 新建一个HTML文件\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v('\\n<div class=\"box\">\\n    // 在这里我们使用自定义属性data-src存储真实的图片地址\\n    <img style=\"margin-top: 600px;\" class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d1e26e2947?w=533&h=300&f=jpeg&s=44672\"\\n        alt=\"\">\\n    <img class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d1e28ba479?w=500&h=463&f=jpeg&s=10435\"\\n        alt=\"\">\\n    <img class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d1e5b3c69c?w=579&h=300&f=jpeg&s=23132\"\\n        alt=\"\">\\n    <img class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d1e60d6bc9?w=500&h=394&f=jpeg&s=27013\"\\n        alt=\"\">\\n    <img class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d1e5ac147c?w=500&h=313&f=jpeg&s=29734\"\\n        alt=\"\">\\n    <img class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d1e5d0a8ef?w=428&h=600&f=jpeg&s=37727\"\\n        alt=\"\">\\n    <img class=\"img\" src=\"\"\\n        data-src=\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7d2033996bc?w=500&h=325&f=jpeg&s=9951\"\\n        alt=\"\">\\n</div>\\n\\n')])])]),r(\"br\"),t._v(\" \"),r(\"h4\",{attrs:{id:\"新建一个css文件\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#新建一个css文件\"}},[t._v(\"#\")]),t._v(\" 新建一个CSS文件\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"\\n.box {\\n    width: 800px;\\n    height: 400px;\\n    border: 1px solid;\\n    overflow: auto;\\n}\\n\\n.img {\\n    width: 100px;\\n    height: 100px;\\n    border: 1px solid;\\n    display: block;\\n    margin: 40px auto;\\n}\\n\\n\")])])]),r(\"p\",[t._v(\"在这里我们基本可以实现一个这样的界面\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a7f190ac9573?w=817&h=416&f=gif&s=26117\",alt:\"\"}})]),t._v(\" \"),r(\"h4\",{attrs:{id:\"实现懒加载\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现懒加载\"}},[t._v(\"#\")]),t._v(\" 实现懒加载\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"\\n1.首先我们先去获取父级元素以及子元素\\n\\nconst box = document.querySelector('.box');\\nconst imgs = document.querySelectorAll('.img');\\n\\n2.监听父级滚动轴变化\\n\\nbox.addEventListener('scroll', handleListenScroll);\\n\\n3.实现监听函数\\n\\nfunction handleListenScroll() {\\n    //获取父级滚动轴距离顶部距离\\n    var scrollTop = box.scrollTop;\\n    \\n    //获取父级高度\\n    var divHeight = box.clientHeight;\\n\\n    for (var i = 0; i < imgs.length; i++){\\n        if (imgs[i].offsetTop < divHeight + scrollTop) {\\n          imgs[i].src = imgs[i].getAttribute('data-src');\\n        }\\n    }\\n}\\n\\n这样一个简单的懒加载就实现了，我们看下效果。\\n\\n\")])])]),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/9/7/16d0a8e985b0fee3?w=1414&h=632&f=gif&s=580084\",alt:\"\"}})]),t._v(\" \"),r(\"h4\",{attrs:{id:\"优化\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#优化\"}},[t._v(\"#\")]),t._v(\" 优化\")]),t._v(\" \"),r(\"p\",[t._v(\"如果直接将函数绑定在scroll事件上，当页面滚动时，函数会被高频触发，这非常影响浏览器的性能。\")]),t._v(\" \"),r(\"blockquote\",[r(\"p\",[t._v(\"所谓\"),r(\"code\",[t._v(\"节流\")]),t._v(\"，就是当持续触发事件时，保证一定时间段内只调用一次事件处理函数。这里也许会有小伙伴说了，\"),r(\"code\",[t._v(\"防抖\")]),t._v(\"呢？先说一下\"),r(\"code\",[t._v(\"防抖\")]),t._v(\"的概念吧，当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。根据我们的场景，显然在这里使用\"),r(\"code\",[t._v(\"防抖\")]),t._v(\"是不太合适的。\")])]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"\\nbox.addEventListener('scroll', throttle(handleListenScroll, 500));\\n\\n//节流实现\\nfunction throttle(func, delay) {\\n    var previous = 0;\\n    return function () {\\n        let now = Date.now();\\n        let context = this;\\n        let args = arguments;\\n        if (now - previous > delay) {\\n            func.apply(context, args);\\n            previous = now;\\n        }\\n    };\\n}\\n\\n\")])])]),r(\"br\"),t._v(\" \"),r(\"blockquote\",[r(\"p\",[t._v(\"小tip 在使用的时候我们也可以给每个图片一个默认图片，等图片出现在可视区域的时候进行一个替换。\")])]),t._v(\" \"),r(\"br\"),t._v(\" \"),r(\"h3\",{attrs:{id:\"交叉观察者\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#交叉观察者\"}},[t._v(\"#\")]),t._v(\" 交叉观察者\")]),t._v(\" \"),r(\"hr\"),t._v(\" \"),r(\"blockquote\",[r(\"p\",[r(\"code\",[t._v(\"交叉观察者\")]),t._v(\"其实就是利用\"),r(\"code\",[t._v(\"IntersectionObserver\")]),t._v(\"接口 (从属于\"),r(\"code\",[t._v(\"Intersection Observer API\")]),t._v(\") 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(\"),r(\"code\",[t._v(\"viewport\")]),t._v(\")交叉状态的方法。祖先元素与视窗(\"),r(\"code\",[t._v(\"viewport\")]),t._v(\")被称为根(\"),r(\"code\",[t._v(\"root\")]),t._v(\")。\")])]),t._v(\" \"),r(\"p\",[t._v(\"用通俗的话来讲就是判断目标元素有没有和父级元素产生交叉行为，一张图说明一切，画的丑，请见谅~~\\n\"),r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/9/7/16d0aa40b2ef4a1e?w=1080&h=1920&f=jpeg&s=274545\",alt:\"\"}})]),t._v(\" \"),r(\"h4\",{attrs:{id:\"兼容性\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#兼容性\"}},[t._v(\"#\")]),t._v(\" 兼容性\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/9/7/16d0aadf95400603?w=984&h=532&f=jpeg&s=80540\",alt:\"\"}})]),t._v(\" \"),r(\"p\",[t._v(\"呃呃呃， IE几乎全军覆没，不过，有官方提供过的\"),r(\"code\",[t._v(\"polyfill\")]),t._v(\"，啥都不用怕，\"),r(\"a\",{attrs:{href:\"https://github.com/w3c/IntersectionObserver/tree/master/polyfill\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"点这里\"),r(\"OutboundLink\")],1),t._v(\"。\")]),t._v(\" \"),r(\"h4\",{attrs:{id:\"属性和方法\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#属性和方法\"}},[t._v(\"#\")]),t._v(\" 属性和方法\")]),t._v(\" \"),r(\"table\",[r(\"thead\",[r(\"tr\",[r(\"th\",[t._v(\"属性\")]),t._v(\" \"),r(\"th\",[t._v(\"介绍\")])])]),t._v(\" \"),r(\"tbody\",[r(\"tr\",[r(\"td\",[t._v(\"root\")]),t._v(\" \"),r(\"td\",[t._v(\"所监听对象的具体祖先元素(element)。如果未传入值或值为null，则默认使用顶级文档的视窗。\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"rootMargin\")]),t._v(\" \"),r(\"td\",[t._v(\"计算交叉时添加到根(root)边界盒bounding box的矩形偏移量， 可以有效的缩小或扩大根的判定范围从而满足计算需要\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"thresholds\")]),t._v(\" \"),r(\"td\",[t._v(\"一个包含阈值的列表, 按升序排列, 列表中的每个阈值都是监听对象的交叉区域与边界区域的比率。\")])])])]),t._v(\" \"),r(\"br\"),t._v(\" \"),r(\"table\",[r(\"thead\",[r(\"tr\",[r(\"th\",[t._v(\"方法\")]),t._v(\" \"),r(\"th\",[t._v(\"介绍\")])])]),t._v(\" \"),r(\"tbody\",[r(\"tr\",[r(\"td\",[t._v(\"disconnect()\")]),t._v(\" \"),r(\"td\",[t._v(\"使IntersectionObserver对象停止监听工作\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"observe()\")]),t._v(\" \"),r(\"td\",[t._v(\"使IntersectionObserver开始监听一个目标元素。\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"takeRecords()\")]),t._v(\" \"),r(\"td\",[t._v(\"返回所有观察目标的IntersectionObserverEntry对象数组。\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"unobserve()\")]),t._v(\" \"),r(\"td\",[t._v(\"使IntersectionObserver停止监听特定目标元素。\")])])])]),t._v(\" \"),r(\"h4\",{attrs:{id:\"使用\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用\"}},[t._v(\"#\")]),t._v(\" 使用\")]),t._v(\" \"),r(\"p\",[t._v(\"1.新建一个\"),r(\"code\",[t._v(\"IntersectionObserver\")]),t._v(\"对象。\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"\\nconst observer = new IntersectionObserver(entries => {\\n    // 发生交叉目标元素集合\\n    console.log(entries);\\n}, option);\\n    \\n在这里callback会返回给我们当前已监听并且发生了交叉的目标集合，我们看一下具体信息。\\n    \\n\")])])]),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/9/7/16d0abb4439eb096?w=1438&h=392&f=png&s=112815\",alt:\"\"}})]),t._v(\" \"),r(\"table\",[r(\"thead\",[r(\"tr\",[r(\"th\",[t._v(\"属性\")]),t._v(\" \"),r(\"th\",[t._v(\"介绍\")])])]),t._v(\" \"),r(\"tbody\",[r(\"tr\",[r(\"td\",[t._v(\"boundingClientRect\")]),t._v(\" \"),r(\"td\",[t._v(\"空间信息\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"target\")]),t._v(\" \"),r(\"td\",[t._v(\"目标元素\")])]),t._v(\" \"),r(\"tr\",[r(\"td\",[t._v(\"isIntersecting\")]),t._v(\" \"),r(\"td\",[t._v(\"是否发生交叉\")])])])]),t._v(\" \"),r(\"p\",[t._v(\"2.监听目标元素\")]),t._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[t._v(\"const box = document.querySelector('.box');\\nconst imgs = document.querySelectorAll('.img');\\n\\nconst observer = new IntersectionObserver(entries => {\\n    // 发生交叉目标元素集合\\n    entries.forEach(item => {\\n        // 判断是否发生交叉\\n        if (item.isIntersecting) {\\n            // 替换目标元素Url\\n            item.target.src = item.target.dataset.src;\\n            // 取消监听此目标元素\\n            observer.unobserve(item.target);\\n        }\\n    });\\n}, {\\n    root: box, // 父级元素\\n    rootMargin: '20px 0px 100px 0px' // 设置偏移 我们可以设置在目标元素距离底部100px的时候发送请求\\n});\\n\\nimgs.forEach(item => {\\n    // 监听目标元素\\n    observer.observe(item);\\n});\\n\\n\")])])]),r(\"h4\",{attrs:{id:\"实现\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#实现\"}},[t._v(\"#\")]),t._v(\" 实现\")]),t._v(\" \"),r(\"p\",[r(\"img\",{attrs:{src:\"https://user-gold-cdn.xitu.io/2019/9/7/16d0aca3c283a5c9?w=1414&h=632&f=gif&s=611402\",alt:\"\"}})]),t._v(\" \"),r(\"blockquote\",[r(\"p\",[t._v(\"以上就是使用\"),r(\"code\",[t._v(\"IntersectionObserver\")]),t._v(\"实现懒加载的过程，是不是很简单呢，在这里我们不再需要去监听滚动条的变化，只需要根据返回给我们的元素集合就可以实现。还要记住必须是子元素跟父元素发生交叉，是不可以去检查两个非父子关系的交叉的情况哦~~\")])]),t._v(\" \"),r(\"br\"),t._v(\" \"),r(\"p\",[t._v(\"综上 就是我对于懒加载一点小见解，也希望未来我们的页面更加流畅，so，先从懒加载开始吧~~。其实懒加载只是通过\"),r(\"code\",[t._v(\"IntersectionObserver\")]),t._v(\"实现的一点小功能，\"),r(\"code\",[t._v(\"IntersectionObserver\")]),t._v(\"还可以帮我们实现\"),r(\"code\",[t._v(\"吸顶\")]),t._v(\"、\"),r(\"code\",[t._v(\"触底\")]),t._v(\"这些功能，感兴趣的小伙伴可以去试试哦。最后，文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞👍和关注，😀。\")]),t._v(\" \"),r(\"h3\",{attrs:{id:\"推荐阅读\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#推荐阅读\"}},[t._v(\"#\")]),t._v(\" 推荐阅读\")]),t._v(\" \"),r(\"hr\"),t._v(\" \"),r(\"ul\",[r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5d6b3b4be51d4562092388a4#heading-8\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"妈耶，这次终于了解继承了！\"),r(\"OutboundLink\")],1)]),t._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5d6b9608f265da03a6532f52\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"妈妈再也不用担心我用不好ECharts了\"),r(\"OutboundLink\")],1)]),t._v(\" \"),r(\"li\",[r(\"a\",{attrs:{href:\"https://juejin.im/post/5d6c731a518825799a553ddd\",target:\"_blank\",rel:\"noopener noreferrer\"}},[t._v(\"一篇文章搞定百度地图基本操作\"),r(\"OutboundLink\")],1)])]),t._v(\" \"),r(\"h4\",{attrs:{id:\"参考\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#参考\"}},[t._v(\"#\")]),t._v(\" 参考\")]),t._v(\" \"),r(\"hr\"),t._v(\" \"),r(\"ul\",[r(\"li\",[t._v(\"https://developer.mozilla.org/zh-CN/docs/Web/API/IntersectionObserver\")]),t._v(\" \"),r(\"li\",[t._v(\"https://juejin.im/post/5d665133e51d4561c83e7c83#heading-2\")])])])}),[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}