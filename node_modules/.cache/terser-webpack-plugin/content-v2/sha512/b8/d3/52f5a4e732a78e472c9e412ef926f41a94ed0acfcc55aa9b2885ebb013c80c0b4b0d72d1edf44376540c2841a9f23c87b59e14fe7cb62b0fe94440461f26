{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{263:function(e,n,a){\"use strict\";a.r(n);var o=a(28),t=Object(o.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h3\",{attrs:{id:\"js部分\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js部分\"}},[e._v(\"#\")]),e._v(\" js部分\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"导读\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#导读\"}},[e._v(\"#\")]),e._v(\" 导读\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"都说金九银十是一个面试的好季节，最近在\"),a(\"code\",[e._v(\"GitHub\")]),e._v(\"上看到了一些关于前端的面试题，也比较基础，在这里整理了一下，因为内容较多，在这里分为\"),a(\"code\",[e._v(\"HTML\")]),e._v(\"、\"),a(\"code\",[e._v(\"CSS\")]),e._v(\"、\"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\"三篇，希望可以对大家有所帮助，趁着“好季节”，找到自己心仪的工作,当然也包括我自己在内，大家一起加油哈！\")])]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"因为掘金的某条沸点，在这里先说明一下，本篇文章适合目前正在找工作或者觉得自己的基础不太扎实的小伙伴，大神就跳过吧O(∩_∩)O。\")])]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"转发自 https://github.com/yangshun/front-end-interview-handbook。\")])]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"a\",{attrs:{href:\"https://juejin.im/post/5d7776875188253a830541db\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"HTML篇地址\"),a(\"OutboundLink\")],1),a(\"br\")]),e._v(\" \"),a(\"li\",[a(\"a\",{attrs:{href:\"https://juejin.im/post/5d77a7416fb9a06ae836370e\",target:\"_blank\",rel:\"noopener noreferrer\"}},[e._v(\"CSS篇地址\"),a(\"OutboundLink\")],1)])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_1-请解释事件委托。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1-请解释事件委托。\"}},[e._v(\"#\")]),e._v(\" 1.请解释事件委托。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"事件委托是将事件监听器添加到父元素，而不是每个子元素单独设置事件监听器。当触发子元素时，事件会冒泡到父元素，监听器就会触发。这种技术的好处是：\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"1.内存占用减少，因为只需要一个父元素的事件处理程序，而不必为每个后代都添加事件处理程序。\"),a(\"br\"),e._v(\"\\n2.无需从已删除的元素中解绑处理程序，也无需将处理程序绑定到新元素上。\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_2-请简述javascript中的this。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2-请简述javascript中的this。\"}},[e._v(\"#\")]),e._v(\" 2.请简述\"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\"中的\"),a(\"code\",[e._v(\"this\")]),e._v(\"。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"JS 中的\"),a(\"font\",{attrs:{color:\"#FF7F50\",size:\"3\"}},[e._v(\" this  \")]),e._v(\"是一个相对复杂的概念，不是简单几句能解释清楚的。粗略地讲，函数的调用方式决定了\"),a(\"font\",{attrs:{color:\"#FF7F50\",size:\"3\"}},[e._v(\" this  \")]),e._v(\"的值。我阅读了网上很多关于\"),a(\"font\",{attrs:{color:\"#FF7F50\",size:\"3\"}},[e._v(\" this  \")]),e._v(\"的文章，Arnav Aggrawal 写的比较清楚。\"),a(\"font\",{attrs:{color:\"#FF7F50\",size:\"3\"}},[e._v(\" this  \")]),e._v(\"取值符合以下规则：\")],1),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"1.在调用函数时使用\"),a(\"code\",[e._v(\"new\")]),e._v(\"关键字，函数内的\"),a(\"code\",[e._v(\"this\")]),e._v(\"是一个全新的对象。\"),a(\"br\"),e._v(\"\\n2.如果\"),a(\"code\",[e._v(\"apply\")]),e._v(\"、\"),a(\"code\",[e._v(\"call\")]),e._v(\"或\"),a(\"code\",[e._v(\"bind\")]),e._v(\"方法用于调用、创建一个函数，函数内的 \"),a(\"code\",[e._v(\"this\")]),e._v(\" 就是作为参数传入这些方法的对象。\"),a(\"br\"),e._v(\"\\n3.当函数作为对象里的方法被调用时，函数内的\"),a(\"code\",[e._v(\"this\")]),e._v(\"是调用该函数的对象。比如当\"),a(\"code\",[e._v(\"obj.method()\")]),e._v(\"被调用时，函数内的 \"),a(\"code\",[e._v(\"this\")]),e._v(\" 将绑定到\"),a(\"code\",[e._v(\"obj\")]),e._v(\"对象。\"),a(\"br\"),e._v(\"\\n4.如果调用函数不符合上述规则，那么\"),a(\"code\",[e._v(\"this\")]),e._v(\"的值指向全局对象\"),a(\"code\",[e._v(\"（global object）\")]),e._v(\"。浏览器环境下\"),a(\"code\",[e._v(\"this\")]),e._v(\"的值指向\"),a(\"code\",[e._v(\"window\")]),e._v(\"对象，但是在严格模式下\"),a(\"code\",[e._v(\"('use strict')\")]),e._v(\"，\"),a(\"code\",[e._v(\"this\")]),e._v(\"的值为\"),a(\"code\",[e._v(\"undefined\")]),e._v(\"。\"),a(\"br\"),e._v(\"\\n5.如果符合上述多个规则，则较高的规则（1 号最高，4 号最低）将决定\"),a(\"code\",[e._v(\"this\")]),e._v(\"的值。\"),a(\"br\"),e._v(\"\\n6.如果该函数是 \"),a(\"code\",[e._v(\"ES2015\")]),e._v(\" 中的箭头函数，将忽略上面的所有规则，\"),a(\"code\",[e._v(\"this\")]),e._v(\"被设置为它被创建时的上下文。\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_3-请解释原型继承的工作原理。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_3-请解释原型继承的工作原理。\"}},[e._v(\"#\")]),e._v(\" 3.请解释原型继承的工作原理。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"这是一个非常常见的 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 问题。所有 \"),a(\"code\",[e._v(\"JS\")]),e._v(\" 对象都有一个\"),a(\"code\",[e._v(\"prototype\")]),e._v(\"属性，指向它的原型对象。当试图访问一个对象的属性时，如果没有在该对象上找到，它还会搜寻该对象的原型，以及该对象的原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾。这种行为是在模拟经典的继承，但是与其说是继承，不如说是委托。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_4-说说你对amd和commonjs的了解。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_4-说说你对amd和commonjs的了解。\"}},[e._v(\"#\")]),e._v(\" 4.说说你对\"),a(\"code\",[e._v(\"AMD\")]),e._v(\"和\"),a(\"code\",[e._v(\"CommonJS\")]),e._v(\"的了解。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"它们都是实现模块体系的方式，直到\"),a(\"code\",[e._v(\"ES2015\")]),e._v(\"出现之前，\"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 一直没有模块体系。\"),a(\"code\",[e._v(\"CommonJS\")]),e._v(\" 是同步的，而 \"),a(\"code\",[e._v(\"AMD（Asynchronous Module Definition）\")]),e._v(\"从全称中可以明显看出是异步的。\"),a(\"code\",[e._v(\"CommonJS\")]),e._v(\" 的设计是为服务器端开发考虑的，而\"),a(\"code\",[e._v(\"AMD\")]),e._v(\"支持异步加载模块，更适合浏览器。\")]),e._v(\" \"),a(\"p\",[e._v(\"我发现\"),a(\"code\",[e._v(\"AMD\")]),e._v(\"的语法非常冗长，\"),a(\"code\",[e._v(\"CommonJS\")]),e._v(\"更接近其他语言\"),a(\"code\",[e._v(\"import\")]),e._v(\" 声明语句的用法习惯。大多数情况下，我认为\"),a(\"code\",[e._v(\"AMD\")]),e._v(\"没有使用的必要，因为如果把所有 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 都捆绑进一个文件中，将无法得到异步加载的好处。此外，\"),a(\"code\",[e._v(\"CommonJS 语法上更接近 Node 编写模块的风格，在前后端都使用 JavaScript\")]),e._v(\"开发之间进行切换时，语境的切换开销较小。\")]),e._v(\" \"),a(\"p\",[e._v(\"我很高兴看到\"),a(\"code\",[e._v(\"ES2015\")]),e._v(\" 的模块加载方案同时支持同步和异步，我们终于可以只使用一种方案了。虽然它尚未在浏览器和\"),a(\"code\",[e._v(\"Node\")]),e._v(\"中完全推出，但是我们可以使用代码转换工具进行转换。\")]),e._v(\" \"),a(\"h4\",{attrs:{id:\"_5-请解释下面代码为什么不能用作iife：function-foo-，需要作出哪些修改才能使其成为iife？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_5-请解释下面代码为什么不能用作iife：function-foo-，需要作出哪些修改才能使其成为iife？\"}},[e._v(\"#\")]),e._v(\" 5.请解释下面代码为什么不能用作\"),a(\"code\",[e._v(\"IIFE：function foo(){ }();\")]),e._v(\"，需要作出哪些修改才能使其成为\"),a(\"code\",[e._v(\"IIFE\")]),e._v(\"？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"IIFE（Immediately Invoked Function Expressions）\")]),e._v(\"代表立即执行函数。 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 解析器将 \"),a(\"code\",[e._v(\"function foo(){ }();\")]),e._v(\"解析成 \"),a(\"code\",[e._v(\"function foo(){ }和();\")]),e._v(\" 。其中，前者是函数声明；后者（一对括号）是试图调用一个函数，却没有指定名称，因此它会抛出\"),a(\"code\",[e._v(\"Uncaught SyntaxError: Unexpected token )\")]),e._v(\"的错误。\")]),e._v(\" \"),a(\"p\",[e._v(\"修改方法是：再添加一对括号，形式上有两种：\"),a(\"code\",[e._v(\"(function foo(){ })()\")]),e._v(\"和\"),a(\"code\",[e._v(\"(function foo(){ }())\")]),e._v(\"。以上函数不会暴露到全局作用域，如果不需要在函数内部引用自身，可以省略函数的名称。\")]),e._v(\" \"),a(\"p\",[e._v(\"你可能会用到\"),a(\"code\",[e._v(\"void\")]),e._v(\"操作符：\"),a(\"code\",[e._v(\"void function foo(){ }();\")]),e._v(\"。但是，这种做法是有问题的。表达式的值是\"),a(\"code\",[e._v(\"undefined\")]),e._v(\"，所以如果你的\"),a(\"code\",[e._v(\"IIFE\")]),e._v(\" 有返回值，不要用这种做法。例如：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nconst foo = void function bar() { return 'foo'; }();\\n\\nconsole.log(foo); // undefined\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_6-null、undefined和未声明变量之间有什么区别？如何检查判断这些状态值？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_6-null、undefined和未声明变量之间有什么区别？如何检查判断这些状态值？\"}},[e._v(\"#\")]),e._v(\" 6.\"),a(\"code\",[e._v(\"null\")]),e._v(\"、\"),a(\"code\",[e._v(\"undefined\")]),e._v(\"和未声明变量之间有什么区别？如何检查判断这些状态值？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"当你没有提前使用\"),a(\"code\",[e._v(\"var\")]),e._v(\" 、\"),a(\"code\",[e._v(\"let\")]),e._v(\"或\"),a(\"code\",[e._v(\"const\")]),e._v(\"声明变量，就为一个变量赋值时，该变量是未声明变量\"),a(\"code\",[e._v(\"（undeclared variables）\")]),e._v(\"。未声明变量会脱离当前作用域，成为全局作用域下定义的变量。在严格模式下，给未声明的变量赋值，会抛出\"),a(\"code\",[e._v(\"ReferenceError\")]),e._v(\"错误。和使用全局变量一样，使用未声明变量也是非常不好的做法，应当尽可能避免。要检查判断它们，需要将用到它们的代码放在\"),a(\"code\",[e._v(\"try/catch\")]),e._v(\"语句中。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction foo() {\\n  x = 1; // 在严格模式下，抛出 ReferenceError 错误\\n}\\n\\nfoo();\\nconsole.log(x); // 1\\n\\n\")])])]),a(\"p\",[e._v(\"当一个变量已经声明，但没有赋值时，该变量的值是\"),a(\"code\",[e._v(\"undefined\")]),e._v(\"。如果一个函数的执行结果被赋值给一个变量，但是这个函数却没有返回任何值，那么该变量的值是\"),a(\"code\",[e._v(\"undefined\")]),e._v(\"。要检查它，需要使用严格相等（===）；或者使用\"),a(\"code\",[e._v(\"typeof\")]),e._v(\"，它会返回 \"),a(\"code\",[e._v(\"'undefined'\")]),e._v(\"字符串。请注意，不能使用非严格相等（==）来检查，因为如果变量值为\"),a(\"code\",[e._v(\"null\")]),e._v(\"，使用非严格相等也会返回\"),a(\"code\",[e._v(\"true\")]),e._v(\"。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nvar foo;\\nconsole.log(foo); // undefined\\nconsole.log(foo === undefined); // true\\nconsole.log(typeof foo === 'undefined'); // true\\n\\nconsole.log(foo == null); // true. 错误，不要使用非严格相等！\\n\\nfunction bar() {}\\nvar baz = bar();\\nconsole.log(baz); // undefined\\n\\n\")])])]),a(\"p\",[a(\"code\",[e._v(\"null\")]),e._v(\"只能被显式赋值给变量。它表示空值，与被显式赋值 \"),a(\"code\",[e._v(\"undefined\")]),e._v(\" 的意义不同。要检查判断\"),a(\"code\",[e._v(\"null\")]),e._v(\"值，需要使用严格相等运算符。请注意，和前面一样，不能使用非严格相等（==）来检查，因为如果变量值为\"),a(\"code\",[e._v(\"undefined\")]),e._v(\"，使用非严格相等也会返回\"),a(\"code\",[e._v(\"true\")]),e._v(\"。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nvar foo = null;\\n\\nconsole.log(foo === null); // true\\n\\nconsole.log(foo == undefined); // true. 错误，不要使用非严格相等！\\n\\n\")])])]),a(\"p\",[e._v(\"作为一种个人习惯，我从不使用未声明变量。如果定义了暂时没有用到的变量，我会在声明后明确地给它们赋值为\"),a(\"code\",[e._v(\"null\")]),e._v(\"。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_7-什么是闭包，为什么使用闭包？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_7-什么是闭包，为什么使用闭包？\"}},[e._v(\"#\")]),e._v(\" 7.什么是闭包，为什么使用闭包？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"闭包是函数和声明该函数的词法环境的组合。词法作用域中使用的域，是变量在代码中声明的位置所决定的。闭包是即使被外部函数返回，依然可以访问到外部（封闭）函数作用域的函数。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"为什么使用闭包？\"),a(\"br\"),e._v(\"\\n1.利用闭包实现数据私有化或模拟私有方法,这个方式也称为模块模式。\\n\"),a(\"br\"),e._v(\"\\n2.部分参数函数柯里化。\")])]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_8-请说明-foreach循环和-map-循环的主要区别，它们分别在什么情况下使用？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_8-请说明-foreach循环和-map-循环的主要区别，它们分别在什么情况下使用？\"}},[e._v(\"#\")]),e._v(\" 8.请说明\"),a(\"code\",[e._v(\".forEach\")]),e._v(\"循环和\"),a(\"code\",[e._v(\".map()\")]),e._v(\"循环的主要区别，它们分别在什么情况下使用？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"为了理解两者的区别，我们看看它们分别是做什么的。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"1.forEach\\n\\n遍历数组中的元素。\\n为每个元素执行回调。\\n无返回值。\\n\\nconst a = [1, 2, 3];\\nconst doubled = a.forEach((num, index) => {\\n  // 执行与 num、index 相关的代码\\n});\\n\\n// doubled = undefined\\n\\n2.map\\n\\n遍历数组中的元素\\n通过对每个元素调用函数，将每个元素“映射（map）”到一个新元素，从而创建一个新数组。\\n\\nconst a = [1, 2, 3];\\nconst doubled = a.map(num => {\\n  return num * 2;\\n});\\n\\n// doubled = [2, 4, 6]\\n\\n\")])])]),a(\"p\",[a(\"code\",[e._v(\".forEach\")]),e._v(\"和\"),a(\"code\",[e._v(\".map()\")]),e._v(\"的主要区别在于\"),a(\"code\",[e._v(\".map()\")]),e._v(\"返回一个新的数组。如果你想得到一个结果，但不想改变原始数组，用\"),a(\"code\",[e._v(\".map()\")]),e._v(\"。如果你只需要在数组上做迭代修改，用\"),a(\"code\",[e._v(\"forEach\")]),e._v(\"。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_9-匿名函数的典型应用场景是什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_9-匿名函数的典型应用场景是什么？\"}},[e._v(\"#\")]),e._v(\" 9.匿名函数的典型应用场景是什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"匿名函数可以在\"),a(\"code\",[e._v(\"IIFE\")]),e._v(\"中使用，来封装局部作用域内的代码，以便其声明的变量不会暴露到全局作用域。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n(function() {\\n  // 一些代码。\\n})();\\n\\n匿名函数可以作为只用一次，不需要在其他地方使用的回调函数。当处理函数在调用它们的程序内部被定义时，代码具有更好地自闭性和可读性，可以省去寻找该处理函数的函数体位置的麻烦。\\n\\nsetTimeout(function() {\\n  console.log('Hello world!');\\n}, 1000);\\n\\n匿名函数可以用于函数式编程或 Lodash（类似于回调函数）。\\n\\nconst arr = [1, 2, 3];\\nconst double = arr.map(function(el) {\\n  return el * 2;\\n});\\nconsole.log(double); // [2, 4, 6]\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_10-你如何组织自己的代码？（使用模块模式（module-pattern）还是经典继承（classical-inheritance）？）\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_10-你如何组织自己的代码？（使用模块模式（module-pattern）还是经典继承（classical-inheritance）？）\"}},[e._v(\"#\")]),e._v(\" 10.你如何组织自己的代码？（使用模块模式（module pattern）还是经典继承（classical inheritance）？）\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"我以前使用 \"),a(\"code\",[e._v(\"Backbone\")]),e._v(\" 组织我的模型 \"),a(\"code\",[e._v(\"（model）\")]),e._v(\"，\"),a(\"code\",[e._v(\"Backbone\")]),e._v(\" 鼓励采用面向对象的方法——创建 \"),a(\"code\",[e._v(\"Backbone\")]),e._v(\" 模型，并为其添加方法。\")]),e._v(\" \"),a(\"p\",[e._v(\"模块模式仍然是很好的方式，但是现在我使用基于 \"),a(\"code\",[e._v(\"React/Redux\")]),e._v(\" 的 \"),a(\"code\",[e._v(\"Flux\")]),e._v(\"体系结构，它鼓励使用单向函数编程的方法。我用普通对象 \"),a(\"code\",[e._v(\"（plain object）\")]),e._v(\" 表示我的 \"),a(\"code\",[e._v(\"app\")]),e._v(\" 模型，编写实用纯函数去操作这些对象。使用动作 \"),a(\"code\",[e._v(\"（actions）\")]),e._v(\" 和化简器 \"),a(\"code\",[e._v(\"（reducers）\")]),e._v(\" 来处理状态，就像其他 \"),a(\"code\",[e._v(\"Redux\")]),e._v(\" 应用一样。\")]),e._v(\" \"),a(\"p\",[e._v(\"我尽可能避免使用经典继承。如果非要这么做，我会坚持这些原则。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_11-宿主对象-（host-objects）-和原生对象-（native-objects）-的区别是什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_11-宿主对象-（host-objects）-和原生对象-（native-objects）-的区别是什么？\"}},[e._v(\"#\")]),e._v(\" 11.宿主对象 \"),a(\"code\",[e._v(\"（host objects）\")]),e._v(\" 和原生对象 \"),a(\"code\",[e._v(\"（native objects）\")]),e._v(\" 的区别是什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"原生对象是由 \"),a(\"code\",[e._v(\"ECMAScript\")]),e._v(\" 规范定义的 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\"内置对象，比如\"),a(\"code\",[e._v(\"String\")]),e._v(\"、\"),a(\"code\",[e._v(\"Math\")]),e._v(\"、\"),a(\"code\",[e._v(\"RegExp\")]),e._v(\"、\"),a(\"code\",[e._v(\"Object\")]),e._v(\"、\"),a(\"code\",[e._v(\"Function\")]),e._v(\"等等。\")]),e._v(\" \"),a(\"p\",[e._v(\"宿主对象是由运行时环境（浏览器或 \"),a(\"code\",[e._v(\"Node\")]),e._v(\"）提供，比如 \"),a(\"code\",[e._v(\"window\")]),e._v(\"、\"),a(\"code\",[e._v(\"XMLHTTPRequest\")]),e._v(\" 等等。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_12-下列语句有什么区别：\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_12-下列语句有什么区别：\"}},[e._v(\"#\")]),e._v(\" 12.下列语句有什么区别：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction Person(){}\\n\\nvar person = Person()\\n\\nvar person = new Person()\\n\\n\")])])]),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"这个问题问得很含糊。我猜这是在考察 JavaScript 中的构造函数（constructor）。从技术上讲，function Person(){}只是一个普通的函数声明。使用 PascalCase 方式命名函数作为构造函数，是一个惯例。\")]),e._v(\" \"),a(\"p\",[e._v(\"var person = Person()将Person以普通函数调用，而不是构造函数。如果该函数是用作构造函数的，那么这种调用方式是一种常见错误。通常情况下，构造函数不会返回任何东西，因此，像普通函数一样调用构造函数，只会返回undefined赋给用作实例的变量。\")]),e._v(\" \"),a(\"p\",[e._v(\"var person = new Person()使用new操作符，创建Person对象的实例，该实例继承自Person.prototype。另外一种方式是使用\"),a(\"code\",[e._v(\"Object.create\")]),e._v(\"，例如：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nObject.create(Person.prototype)`。\\n\\nfunction Person(name) {\\n  this.name = name;\\n}\\n\\nvar person = Person('John');\\nconsole.log(person); // undefined\\nconsole.log(person.name); // Uncaught TypeError: Cannot read property 'name' of undefined\\n\\nvar person = new Person('John');\\nconsole.log(person); // Person { name: \\\"John\\\" }\\nconsole.log(person.name); // \\\"john\\\"\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_13-call-和-apply有什么区别？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_13-call-和-apply有什么区别？\"}},[e._v(\"#\")]),e._v(\" 13.\"),a(\"code\",[e._v(\".call\")]),e._v(\" 和 \"),a(\"code\",[e._v(\".apply\")]),e._v(\"有什么区别？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\".call\")]),e._v(\"和\"),a(\"code\",[e._v(\".apply\")]),e._v(\"都用于调用函数，第一个参数将用作函数内 \"),a(\"code\",[e._v(\"this\")]),e._v(\" 的值。然而，\"),a(\"code\",[e._v(\".call\")]),e._v(\"接受逗号分隔的参数作为后面的参数，而 \"),a(\"code\",[e._v(\".apply\")]),e._v(\"接受一个参数数组作为后面的参数。一个简单的记忆方法是，从\"),a(\"code\",[e._v(\"call\")]),e._v(\"中的 \"),a(\"code\",[e._v(\"C\")]),e._v(\" 联想到逗号分隔（comma-separated），从\"),a(\"code\",[e._v(\"apply\")]),e._v(\"中的 \"),a(\"code\",[e._v(\"A\")]),e._v(\" 联想到数组（array）。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction add(a, b) {\\n  return a + b;\\n}\\n\\nconsole.log(add.call(null, 1, 2)); // 3\\nconsole.log(add.apply(null, [1, 2])); // 3\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_14-请说明-function-prototype-bind-的用法。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_14-请说明-function-prototype-bind-的用法。\"}},[e._v(\"#\")]),e._v(\" 14.请说明 \"),a(\"code\",[e._v(\"Function.prototype.bind\")]),e._v(\" 的用法。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"摘自\"),a(\"code\",[e._v(\"MDN\")]),e._v(\"：\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"bind()\")]),e._v(\"方法创建一个新的函数, 当被调用时，将其 \"),a(\"code\",[e._v(\"this\")]),e._v(\" 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。\")]),e._v(\" \"),a(\"p\",[e._v(\"根据我的经验，将\"),a(\"code\",[e._v(\"this\")]),e._v(\"的值绑定到想要传递给其他函数的类的方法中是非常有用的。在 \"),a(\"code\",[e._v(\"React\")]),e._v(\" 组件中经常这样做。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_15-什么时候会用到document-write-？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_15-什么时候会用到document-write-？\"}},[e._v(\"#\")]),e._v(\" 15.什么时候会用到\"),a(\"code\",[e._v(\"document.write()\")]),e._v(\"？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"document.write()\")]),e._v(\"用来将一串文本写入由\"),a(\"code\",[e._v(\"document.open()\")]),e._v(\"打开的文档流中。当页面加载后执行\"),a(\"code\",[e._v(\"document.write()\")]),e._v(\"时，它将调用\"),a(\"code\",[e._v(\"document.open\")]),e._v(\"，会清除整个文档（\"),a(\"code\",[e._v(\"<head>\")]),e._v(\"和\"),a(\"code\",[e._v(\"<body>\")]),e._v(\"会被移除！），并将文档内容替换成给定的字符串参数。因此它通常被认为是危险的并且容易被误用。\")]),e._v(\" \"),a(\"p\",[e._v(\"网上有一些答案，解释了\"),a(\"code\",[e._v(\"document.write()\")]),e._v(\"被用于分析代码中，或者当你想包含只有在启用了 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 的情况下才能工作的样式。它甚至在 \"),a(\"code\",[e._v(\"HTML5\")]),e._v(\" 样板代码中用于并行加载脚本并保持执行顺序！但是，我怀疑这些使用原因是过时的，现在可以在不使用\"),a(\"code\",[e._v(\"document.write()\")]),e._v(\"的情况下实现。如果我的观点有错，请纠正我。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_16-请尽可能详细地解释-ajax。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_16-请尽可能详细地解释-ajax。\"}},[e._v(\"#\")]),e._v(\" 16.请尽可能详细地解释 \"),a(\"code\",[e._v(\"Ajax\")]),e._v(\"。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"Ajax（asynchronous JavaScript and XML）\")]),e._v(\"是使用客户端上的许多 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 技术，创建异步 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 应用的一种 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 开发技术。借助 \"),a(\"code\",[e._v(\"Ajax\")]),e._v(\"，\"),a(\"code\",[e._v(\"Web\")]),e._v(\" 应用可以异步（在后台）向服务器发送数据和从服务器检索数据，而不会干扰现有页面的显示和行为。通过将数据交换层与表示层分离，\"),a(\"code\",[e._v(\"Ajax\")]),e._v(\" 允许网页和扩展 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 应用程序动态更改内容，而无需重新加载整个页面。实际上，现在通常将 \"),a(\"code\",[e._v(\"XML\")]),e._v(\" 替换为 \"),a(\"code\",[e._v(\"JSON\")]),e._v(\"，因为 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 对 \"),a(\"code\",[e._v(\"JSON\")]),e._v(\" 有原生支持优势。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"XMLHttpRequest API\")]),e._v(\"  经常用于异步通信。此外还有最近流行的\"),a(\"code\",[e._v(\"fetch API\")]),e._v(\"。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_17-使用-ajax-的优缺点分别是什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_17-使用-ajax-的优缺点分别是什么？\"}},[e._v(\"#\")]),e._v(\" 17.使用 Ajax 的优缺点分别是什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"优点\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[e._v(\"交互性更好。来自服务器的新内容可以动态更改，无需重新加载整个页面。\\n减少与服务器的连接，因为脚本和样式只需要被请求一次。\\n状态可以维护在一个页面上。JavaScript 变量和 DOM 状态将得到保持，因为主容器页面未被重新加载。\\n基本上包括大部分 SPA 的优点。\\n\")])])]),a(\"p\",[e._v(\"缺点\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[e._v(\"动态网页很难收藏。\\n如果 JavaScript 已在浏览器中被禁用，则不起作用。\\n有些网络爬虫不执行 JavaScript，也不会看到 JavaScript 加载的内容。\\n基本上包括大部分 SPA 的缺点。\\n\")])])]),a(\"h3\",{attrs:{id:\"_18-请说明-jsonp-的工作原理，它为什么不是真正的-ajax？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_18-请说明-jsonp-的工作原理，它为什么不是真正的-ajax？\"}},[e._v(\"#\")]),e._v(\" 18.请说明 \"),a(\"code\",[e._v(\"JSONP\")]),e._v(\" 的工作原理，它为什么不是真正的 \"),a(\"code\",[e._v(\"Ajax\")]),e._v(\"？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"JSONP\")]),e._v(\"（带填充的 \"),a(\"code\",[e._v(\"JSON\")]),e._v(\"）是一种通常用于绕过 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 浏览器中的跨域限制的方法，因为 \"),a(\"code\",[e._v(\"Ajax\")]),e._v(\" 不允许跨域请求。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"JSONP\")]),e._v(\" 通过\"),a(\"code\",[e._v(\"<script>\")]),e._v(\"标签发送跨域请求，通常使用\"),a(\"code\",[e._v(\"callback\")]),e._v(\"查询参数，例如：https://example.com?callback=printData。 然后服务器将数据包装在一个名为\"),a(\"code\",[e._v(\"printData\")]),e._v(\"的函数中并将其返回给客户端。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n\\x3c!-- https://mydomain.com --\\x3e\\n<script>\\nfunction printData(data) {\\n  console.log(`My name is ${data.name}!`);\\n}\\n<\\/script>\\n\\n<script src=\\\"https://example.com?callback=printData\\\"><\\/script>\\nprintData({ name: 'Yang Shun' });\\n\\n\")])])]),a(\"p\",[e._v(\"客户端必须在其全局范围内具有\"),a(\"code\",[e._v(\"printData\")]),e._v(\"函数，并且在收到来自跨域的响应时，该函数将由客户端执行。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"JSONP\")]),e._v(\" 可能具有一些安全隐患。由于 \"),a(\"code\",[e._v(\"JSONP\")]),e._v(\" 是纯 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 实现，它可以完成 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 所能做的一切，因此需要信任 \"),a(\"code\",[e._v(\"JSONP\")]),e._v(\" 数据的提供者。\")]),e._v(\" \"),a(\"p\",[e._v(\"现如今，跨来源资源共享（\"),a(\"code\",[e._v(\"CORS\")]),e._v(\"） 是推荐的主流方式，\"),a(\"code\",[e._v(\"JSONP\")]),e._v(\" 已被视为一种比较 \"),a(\"code\",[e._v(\"hack\")]),e._v(\" 的方式。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_19-请解释变量提升。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_19-请解释变量提升。\"}},[e._v(\"#\")]),e._v(\" 19.请解释变量提升。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"变量提升（\"),a(\"code\",[e._v(\"hoisting\")]),e._v(\"）是用于解释代码中变量声明行为的术语。使用\"),a(\"code\",[e._v(\"var\")]),e._v(\"关键字声明或初始化的变量，会将声明语句“提升”到当前作用域的顶部。 但是，只有声明才会触发提升，赋值语句（如果有的话）将保持原样。我们用几个例子来解释一下。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"// 用 var 声明得到提升\\nconsole.log(foo); // undefined\\n\\nvar foo = 1;\\n\\nconsole.log(foo); // 1\\n\\n// 用 let/const 声明不会提升\\nconsole.log(bar); // ReferenceError: bar is not defined\\n\\nlet bar = 2;\\n\\nconsole.log(bar); // 2\\n\\n函数声明会使函数体提升，但函数表达式（以声明变量的形式书写）只有变量声明会被提升。\\n\\n// 函数声明\\nconsole.log(foo); // [Function: foo]\\n\\nfoo(); // 'FOOOOO'\\n\\nfunction foo() {\\n\\n  console.log('FOOOOO');\\n  \\n}\\nconsole.log(foo); // [Function: foo]\\n\\n// 函数表达式\\nconsole.log(bar); // undefined\\n\\nbar(); // Uncaught TypeError: bar is not a function\\n\\nvar bar = function() {\\n\\n  console.log('BARRRR');\\n  \\n};\\n\\nconsole.log(bar); // [Function: bar]\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_20-请描述事件冒泡。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_20-请描述事件冒泡。\"}},[e._v(\"#\")]),e._v(\" 20.请描述事件冒泡。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"当一个事件在 \"),a(\"code\",[e._v(\"DOM\")]),e._v(\" 元素上触发时，如果有事件监听器，它将尝试处理该事件，然后事件冒泡到其父级元素，并发生同样的事情。最后直到事件到达祖先元素。事件冒泡是实现事件委托的原理（\"),a(\"code\",[e._v(\"event delegation\")]),e._v(\"）。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_21-attribute-和-property-之间有什么区别？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_21-attribute-和-property-之间有什么区别？\"}},[e._v(\"#\")]),e._v(\" 21.“\"),a(\"code\",[e._v(\"attribute\")]),e._v(\"” 和 “\"),a(\"code\",[e._v(\"property\")]),e._v(\"” 之间有什么区别？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"“\"),a(\"code\",[e._v(\"Attribute\")]),e._v(\"” 是在 \"),a(\"code\",[e._v(\"HTML\")]),e._v(\" 中定义的，而 “\"),a(\"code\",[e._v(\"property\")]),e._v(\"” 是在 \"),a(\"code\",[e._v(\"DOM\")]),e._v(\" 上定义的。为了说明区别，假设我们在 \"),a(\"code\",[e._v(\"HTML\")]),e._v(\" 中有一个文本框：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n<input type=\\\"text\\\" value=\\\"Hello\\\">。\\n\\nconst input = document.querySelector('input');\\nconsole.log(input.getAttribute('value')); // Hello\\nconsole.log(input.value); // Hello\\n\\n但是在文本框中键入“ World!”后:\\n\\nconsole.log(input.getAttribute('value')); // Hello\\nconsole.log(input.value); // Hello World!\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_22-为什么扩展-javascript-内置对象是不好的做法？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_22-为什么扩展-javascript-内置对象是不好的做法？\"}},[e._v(\"#\")]),e._v(\" 22.为什么扩展 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 内置对象是不好的做法？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"扩展 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 内置（原生）对象意味着将属性或方法添加到其\"),a(\"code\",[e._v(\"prototype\")]),e._v(\"中。虽然听起来很不错，但事实上这样做很危险。想象一下，你的代码使用了一些库，它们通过添加相同的 \"),a(\"code\",[e._v(\"contains\")]),e._v(\" 方法来扩展\"),a(\"code\",[e._v(\"Array.prototype\")]),e._v(\"，如果这两个方法的行为不相同，那么这些实现将会相互覆盖，你的代码将不能正常运行。\")]),e._v(\" \"),a(\"p\",[e._v(\"扩展内置对象的唯一使用场景是创建 \"),a(\"code\",[e._v(\"polyfill\")]),e._v(\"，本质上为老版本浏览器缺失的方法提供自己的实现，该方法是由 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 规范定义的。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_23-document-中的load事件和domcontentloaded事件之间的区别是什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_23-document-中的load事件和domcontentloaded事件之间的区别是什么？\"}},[e._v(\"#\")]),e._v(\" 23.\"),a(\"code\",[e._v(\"document\")]),e._v(\" 中的\"),a(\"code\",[e._v(\"load\")]),e._v(\"事件和\"),a(\"code\",[e._v(\"DOMContentLoaded\")]),e._v(\"事件之间的区别是什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"当初始的 \"),a(\"code\",[e._v(\"HTML\")]),e._v(\" 文档被完全加载和解析完成之后，\"),a(\"code\",[e._v(\"DOMContentLoaded\")]),e._v(\"事件被触发，而无需等待样式表、图像和子框架的完成加载。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"window\")]),e._v(\"的\"),a(\"code\",[e._v(\"load\")]),e._v(\"事件仅在 \"),a(\"code\",[e._v(\"DOM\")]),e._v(\" 和所有相关资源全部完成加载后才会触发。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_24-和-的区别是什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_24-和-的区别是什么？\"}},[e._v(\"#\")]),e._v(\" 24.\"),a(\"code\",[e._v(\"==\")]),e._v(\"和\"),a(\"code\",[e._v(\"===\")]),e._v(\"的区别是什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"==\")]),e._v(\"是抽象相等运算符，而\"),a(\"code\",[e._v(\"===\")]),e._v(\"是严格相等运算符。\"),a(\"code\",[e._v(\"==\")]),e._v(\"运算符是在进行必要的类型转换后，再比较。\"),a(\"code\",[e._v(\"===\")]),e._v(\"运算符不会进行类型转换，所以如果两个值不是相同的类型，会直接返回\"),a(\"code\",[e._v(\"false\")]),e._v(\"。使用\"),a(\"code\",[e._v(\"==\")]),e._v(\"时，可能发生一些特别的事情，例如：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n1 == '1'; // true\\n1 == [1]; // true\\n1 == true; // true\\n0 == ''; // true\\n0 == '0'; // true\\n0 == false; // true\\n我的建议是从不使用==运算符，除了方便与null或undefined比较时，a == null如果a为null或undefined将返回true。\\n\\nvar a = null;\\nconsole.log(a == null); // true\\nconsole.log(a == undefined); // true\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_25-请解释关于-javascript-的同源策略。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_25-请解释关于-javascript-的同源策略。\"}},[e._v(\"#\")]),e._v(\" 25.请解释关于 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 的同源策略。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"同源策略可防止 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 发起跨域请求。源被定义为 \"),a(\"code\",[e._v(\"URI\")]),e._v(\"、\"),a(\"code\",[e._v(\"主机名\")]),e._v(\"和\"),a(\"code\",[e._v(\"端口号\")]),e._v(\"的组合。此策略可防止页面上的恶意脚本通过该页面的文档对象模型，访问另一个网页上的敏感数据。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_26-请使下面的语句生效：\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_26-请使下面的语句生效：\"}},[e._v(\"#\")]),e._v(\" 26.请使下面的语句生效：\")]),e._v(\" \"),a(\"h2\",{attrs:{id:\"duplicate-1-2-3-4-5-1-2-3-4-5-1-2-3-4-5\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#duplicate-1-2-3-4-5-1-2-3-4-5-1-2-3-4-5\"}},[e._v(\"#\")]),e._v(\" \"),a(\"code\",[e._v(\"duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]\")])]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"function duplicate(arr) {\\n  return arr.concat(arr);\\n}\\n\\nduplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_27-请说明三元表达式中-三元-这个词代表什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_27-请说明三元表达式中-三元-这个词代表什么？\"}},[e._v(\"#\")]),e._v(\" 27.请说明三元表达式中“\"),a(\"code\",[e._v(\"三元\")]),e._v(\"”这个词代表什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"“\"),a(\"code\",[e._v(\"三元\")]),e._v(\"”表示接受三个操作数：\"),a(\"code\",[e._v(\"判断条件\")]),e._v(\"，\"),a(\"code\",[e._v(\"then表达式\")]),e._v(\"和\"),a(\"code\",[e._v(\"else\")]),e._v(\"表达式。三元表达式不是 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 特有的，我不知道这个问题为什么会出现在这里。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_28-什么是-use-strict-？使用它有什么优缺点？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_28-什么是-use-strict-？使用它有什么优缺点？\"}},[e._v(\"#\")]),e._v(' 28.什么是\"'),a(\"code\",[e._v(\"use strict\")]),e._v('\";？使用它有什么优缺点？')]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"'\"),a(\"code\",[e._v(\"use strict\")]),e._v(\"' 是用于对整个脚本或单个函数启用严格模式的语句。严格模式是可选择的一个限制 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 的变体一种方式 。\")]),e._v(\" \"),a(\"p\",[e._v(\"优点：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[e._v(\"无法再意外创建全局变量。\\n会使引起静默失败（silently fail，即：不报错也没有任何效果）的赋值操抛出异常。\\n试图删除不可删除的属性时会抛出异常（之前这种操作不会产生任何效果）。\\n要求函数的参数名唯一。\\n全局作用域下，this的值为undefined。\\n捕获了一些常见的编码错误，并抛出异常。\\n禁用令人困惑或欠佳的功能。\\n\")])])]),a(\"p\",[e._v(\"缺点：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[e._v(\"缺失许多开发人员已经习惯的功能。\\n无法访问function.caller和function.arguments。\\n以不同严格模式编写的脚本合并后可能导致问题。\\n总的来说，我认为利大于弊，我从来不使用严格模式禁用的功能，因此我推荐使用严格模式。\\n\")])])]),a(\"h3\",{attrs:{id:\"_29-创建一个循环，从-1-迭代到-100，3的倍数时输出-fizz-，5的倍数时输出-buzz-，同时为3和5的倍数时输出-fizzbuzz-。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_29-创建一个循环，从-1-迭代到-100，3的倍数时输出-fizz-，5的倍数时输出-buzz-，同时为3和5的倍数时输出-fizzbuzz-。\"}},[e._v(\"#\")]),e._v(' 29.创建一个循环，从 1 迭代到 100，3的倍数时输出 \"'),a(\"code\",[e._v(\"fizz\")]),e._v('\"，5的倍数时输出 \"buzz\"，同时为3和5的倍数时输出 \"'),a(\"code\",[e._v(\"fizzbuzz\")]),e._v('\"。')]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfor (let i = 1; i <= 100; i++) {\\n  let f = i % 3 == 0,\\n    b = i % 5 == 0;\\n  console.log(f ? (b ? 'FizzBuzz' : 'Fizz') : b ? 'Buzz' : i);\\n}\\n\\n\")])])]),a(\"p\",[e._v(\"我不建议你在面试时写上面的代码。只要写得清晰即可。关于更多千奇百怪的 FizzBuzz 实现，请查看下面的参考链接。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_30-为什么不要使用全局作用域？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_30-为什么不要使用全局作用域？\"}},[e._v(\"#\")]),e._v(\" 30.为什么不要使用全局作用域？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"每个脚本都可以访问全局作用域，如果人人都使用全局命名空间来定义自己的变量，肯定会发生冲突。使用模块模式（IIFE）将变量封装在本地命名空间中。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_31-为什么要使用load事件？这个事件有什么缺点吗？你知道一些代替方案吗，为什么使用它们？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_31-为什么要使用load事件？这个事件有什么缺点吗？你知道一些代替方案吗，为什么使用它们？\"}},[e._v(\"#\")]),e._v(\" 31.为什么要使用\"),a(\"code\",[e._v(\"load\")]),e._v(\"事件？这个事件有什么缺点吗？你知道一些代替方案吗，为什么使用它们？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"在文档装载完成后会触发\"),a(\"code\",[e._v(\"load\")]),e._v(\"事件。此时，在文档中的所有对象都在 \"),a(\"code\",[e._v(\"DOM\")]),e._v(\" 中，所有图像、脚本、链接和子框架都完成了加载。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"DOM\")]),e._v(\" 事件\"),a(\"code\",[e._v(\"DOMContentLoaded\")]),e._v(\"将在页面的 \"),a(\"code\",[e._v(\"DOM\")]),e._v(\" 构建完成后触发，但不要等待其他资源完成加载。如果在初始化之前不需要装入整个页面，这个事件是使用首选。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_32-请解释单页应用是什么，如何使其对-seo-友好。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_32-请解释单页应用是什么，如何使其对-seo-友好。\"}},[e._v(\"#\")]),e._v(\" 32.请解释单页应用是什么，如何使其对 SEO 友好。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"现如今，\"),a(\"code\",[e._v(\"Web\")]),e._v(\" 开发人员将他们构建的产品称为 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 应用，而不是网站。虽然这两个术语之间没有严格的区别，但网络应用往往具有高度的交互性和动态性，允许用户执行操作并接收他们的操作响应。在过去，浏览器从服务器接收 \"),a(\"code\",[e._v(\"HTML\")]),e._v(\" 并渲染。当用户导航到其它 \"),a(\"code\",[e._v(\"URL\")]),e._v(\" 时，需要整页刷新，服务器会为新页面发送新的 \"),a(\"code\",[e._v(\"HTML\")]),e._v(\"。这被称为服务器端渲染。\")]),e._v(\" \"),a(\"p\",[e._v(\"然而，在现代的 \"),a(\"code\",[e._v(\"SPA\")]),e._v(\" 中，客户端渲染取而代之。浏览器从服务器加载初始页面、整个应用程序所需的脚本（框架、库、应用代码）和样式表。当用户导航到其他页面时，不会触发页面刷新。该页面的 \"),a(\"code\",[e._v(\"URL\")]),e._v(\" 通过 \"),a(\"code\",[e._v(\"HTML5 History API\")]),e._v(\" 进行更新。浏览器通过 \"),a(\"code\",[e._v(\"AJAX\")]),e._v(\" 请求向服务器检索新页面所需的数据（通常采用 \"),a(\"code\",[e._v(\"JSON\")]),e._v(\" 格式）。然后，\"),a(\"code\",[e._v(\"SPA\")]),e._v(\" 通过 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 来动态更新页面，这些 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 在初始页面加载时已经下载。这种模式类似于原生移动应用的工作方式。\")]),e._v(\" \"),a(\"p\",[e._v(\"好处：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[e._v(\"用户感知响应更快，用户切换页面时，不再看到因页面刷新而导致的白屏。\\n对服务器进行的 HTTP 请求减少，因为对于每个页面加载，不必再次下载相同的资源。\\n客户端和服务器之间的关注点分离。可以为不同平台（例如手机、聊天机器人、智能手表）建立新的客户端，而无需修改服务器代码。只要 API 没有修改，可以单独修改客户端和服务器上的代码。\\n\")])])]),a(\"p\",[e._v(\"坏处：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",[a(\"code\",[e._v(\"由于加载了多个页面所需的框架、应用代码和资源，导致初始页面加载时间较长。\\n服务器还需要进行额外的工作，需要将所有请求路由配置到单个入口点，然后由客户端接管路由。\\nSPA 依赖于 JavaScript 来呈现内容，但并非所有搜索引擎都在抓取过程中执行 JavaScript，他们可能会在你的页面上看到空的内容。这无意中损害了应用的搜索引擎优化（SEO）。然而，当你构建应用时，大多数情况下，搜索引擎优化并不是最重要的因素，因为并非所有内容都需要通过搜索引擎进行索引。为了解决这个问题，可以在服务器端渲染你的应用，或者使用诸如 Prerender 的服务来“在浏览器中呈现你的 javascript，保存静态 HTML，并将其返回给爬虫”。\\n\")])])]),a(\"h3\",{attrs:{id:\"_33-你对-promises-及其-polyfill-的掌握程度如何？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_33-你对-promises-及其-polyfill-的掌握程度如何？\"}},[e._v(\"#\")]),e._v(\" 33.你对 \"),a(\"code\",[e._v(\"Promises\")]),e._v(\" 及其 \"),a(\"code\",[e._v(\"polyfill\")]),e._v(\" 的掌握程度如何？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"掌握它的工作原理。\"),a(\"code\",[e._v(\"Promise\")]),e._v(\"是一个可能在未来某个时间产生结果的对象：操作成功的结果或失败的原因（例如发生网络错误）。 \"),a(\"code\",[e._v(\"Promise\")]),e._v(\" 可能处于以下三种状态之一：\"),a(\"code\",[e._v(\"fulfilled\")]),e._v(\"、\"),a(\"code\",[e._v(\"rejected\")]),e._v(\" 或 \"),a(\"code\",[e._v(\"pending\")]),e._v(\"。 用户可以对\"),a(\"code\",[e._v(\"Promise\")]),e._v(\"添加回调函数来处理操作成功的结果或失败的原因。\")]),e._v(\" \"),a(\"p\",[e._v(\"一些常见的 \"),a(\"code\",[e._v(\"polyfill\")]),e._v(\" 是\"),a(\"code\",[e._v(\"$.deferred\")]),e._v(\"、\"),a(\"code\",[e._v(\"Q\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"Bluebird\")]),e._v(\"，但不是所有的 \"),a(\"code\",[e._v(\"polyfill\")]),e._v(\" 都符合规范。\"),a(\"code\",[e._v(\"ES2015\")]),e._v(\" 支持\"),a(\"code\",[e._v(\"Promises\")]),e._v(\"，现在通常不需要使用 \"),a(\"code\",[e._v(\"polyfills\")]),e._v(\"。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_34-promise代替回调函数有什么优缺点？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_34-promise代替回调函数有什么优缺点？\"}},[e._v(\"#\")]),e._v(\" 34.Promise代替回调函数有什么优缺点？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n优点：\\n避免可读性极差的回调地狱。\\n使用.then()编写的顺序异步代码，既简单又易读。\\n使用Promise.all()编写并行异步代码变得很容易。\\n\\n缺点：\\n轻微地增加了代码的复杂度（这点存在争议）。\\n在不支持 ES2015 的旧版浏览器中，需要引入 polyfill 才能使用。\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_35-你使用什么工具和技巧调试-javascript-代码？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_35-你使用什么工具和技巧调试-javascript-代码？\"}},[e._v(\"#\")]),e._v(\" 35.你使用什么工具和技巧调试 JavaScript 代码？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nReact 和 Redux\\nReact Devtools\\nRedux Devtools\\nVue\\nVue Devtools\\nJavaScript\\nChrome Devtools\\ndebugger声明\\n使用万金油console.log进行调试\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_36-你使用什么语句遍历对象的属性和数组的元素？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_36-你使用什么语句遍历对象的属性和数组的元素？\"}},[e._v(\"#\")]),e._v(\" 36.你使用什么语句遍历对象的属性和数组的元素？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"对象：\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n1.for循环：for (var property in obj) { console.log(property); }。但是，这还会遍历到它的继承属性，在使用之前，你需要加入obj.hasOwnProperty(property)检查。\\n\\n2.Object.keys()：Object.keys(obj).forEach(function (property) { ... })。Object.keys()方法会返回一个由一个给定对象的自身可枚举属性组成的数组。\\n\\n3.Object.getOwnPropertyNames()：Object.getOwnPropertyNames(obj).forEach(function (property) { ... })。Object.getOwnPropertyNames()方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括 Symbol 值作为名称的属性）组成的数组。\\n数组：\\n\\n4.for loops：for (var i = 0; i < arr.length; i++)。这里的常见错误是var是函数作用域而不是块级作用域，大多数时候你想要迭代变量在块级作用域中。ES2015 引入了具有块级作用域的let，建议使用它。所以就变成了：for (let i = 0; i < arr.length; i++)。\\n\\n5.forEach：arr.forEach(function (el, index) { ... })。这个语句结构有时会更精简，因为如果你所需要的只是数组元素，你不必使用index。还有every和some方法可以让你提前终止遍历。\\n大多数情况下，我更喜欢.forEach方法，但这取决于你想要做什么。for循环有更强的灵活性，比如使用break提前终止循环，或者递增步数大于一。\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_36-请解释可变对象和不可变对象之间的区别。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_36-请解释可变对象和不可变对象之间的区别。\"}},[e._v(\"#\")]),e._v(\" 36.请解释可变对象和不可变对象之间的区别。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"什么是 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 中的不可变对象的例子？\\n不变性有什么优点和缺点？\\n你如何在自己的代码中实现不变性？\\n可变对象 在创建之后是可以被改变的。\")]),e._v(\" \"),a(\"p\",[e._v(\"不可变对象 在创建之后是不可以被改变的。\")]),e._v(\" \"),a(\"p\",[e._v(\"在 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 中，\"),a(\"code\",[e._v(\"string\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"number\")]),e._v(\" 从设计之初就是不可变(\"),a(\"code\",[e._v(\"Immutable\")]),e._v(\")。\\n不可变 其实是保持一个对象状态不变，这样做的好处是使得开发更加简单，可回溯，测试友好，减少了任何可能的副作用。但是，每当你想添加点东西到一个不可变(\"),a(\"code\",[e._v(\"Immutable\")]),e._v(\")对象里时，它一定是先拷贝已存在的值到新实例里，然后再给新实例添加内容，最后返回新实例。相比可变对象，这势必会有更多内存、计算量消耗。\\n比如：构造一个纯函数\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('const student1 = {\\n  school: \\'Baidu\\',\\n  name: \\'HOU Ce\\',\\n  birthdate: \\'1995-12-15\\',\\n};\\n\\nconst changeStudent = (student, newName, newBday) => {\\n  return {\\n    ...student, // 使用解构\\n    name: newName, // 覆盖name属性\\n    birthdate: newBday, // 覆盖birthdate属性\\n  };\\n};\\n\\nconst student2 = changeStudent(student1, \\'YAN Haijing\\', \\'1990-11-10\\');\\n\\n// both students will have the name properties\\n\\nconsole.log(student1, student2);\\n\\n// Object {school: \"Baidu\", name: \"HOU Ce\", birthdate: \"1995-12-15\"}\\n// Object {school: \"Baidu\", name: \"YAN Haijing\", birthdate: \"1990-11-10\"}\\n\\n')])])]),a(\"h3\",{attrs:{id:\"_37-请解释同步和异步函数之间的区别。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_37-请解释同步和异步函数之间的区别。\"}},[e._v(\"#\")]),e._v(\" 37.请解释同步和异步函数之间的区别。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"同步函数阻塞，而异步函数不阻塞。在同步函数中，语句完成后，下一句才执行。在这种情况下，程序可以按照语句的顺序进行精确评估，如果其中一个语句需要很长时间，程序的执行会停滞很长时间。\")]),e._v(\" \"),a(\"p\",[e._v(\"异步函数通常接受回调作为参数，在调用异步函数后立即继续执行下一行。回调函数仅在异步操作完成且调用堆栈为空时调用。诸如从 \"),a(\"code\",[e._v(\"Web\")]),e._v(\" 服务器加载数据或查询数据库等重负载操作应该异步完成，以便主线程可以继续执行其他操作，而不会出现一直阻塞，直到费时操作完成的情况（在浏览器中，界面会卡住）。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_38-什么是事件循环？调用堆栈和任务队列之间有什么区别？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_38-什么是事件循环？调用堆栈和任务队列之间有什么区别？\"}},[e._v(\"#\")]),e._v(\" 38.什么是事件循环？调用堆栈和任务队列之间有什么区别？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"事件循环是一个单线程循环，用于监视调用堆栈并检查是否有工作即将在任务队列中完成。如果调用堆栈为空并且任务队列中有回调函数，则将回调函数出队并推送到调用堆栈中执行。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_39-请解释-function-foo-和-var-foo-function-之间-foo-的用法上的区别。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_39-请解释-function-foo-和-var-foo-function-之间-foo-的用法上的区别。\"}},[e._v(\"#\")]),e._v(\" 39.请解释 \"),a(\"code\",[e._v(\"function foo() {}\")]),e._v(\"和 \"),a(\"code\",[e._v(\"var foo = function() {}\")]),e._v(\" 之间 \"),a(\"code\",[e._v(\"foo\")]),e._v(\" 的用法上的区别。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"前者是函数声明，后者是函数表达式。关键的区别在于函数声明会使函数体提升（具有与变量相同的提升行为），但函数表达式的函数体不能。有关变量提升的更多解释，请参阅上面关于变量提升的问题。如果你试图在定义函数表达式之前调用它，你会得到一个\"),a(\"code\",[e._v(\"Uncaught TypeError: XXX is not a function\")]),e._v(\"的错误。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n函数声明\\n\\nfoo(); // 'FOOOOO'\\nfunction foo() {\\n  console.log('FOOOOO');\\n}\\n函数表达式\\n\\nfoo(); // Uncaught TypeError: foo is not a function\\nvar foo = function() {\\n  console.log('FOOOOO');\\n};\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_40-使用let、var和const创建变量有什么区别？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_40-使用let、var和const创建变量有什么区别？\"}},[e._v(\"#\")]),e._v(\" 40.使用\"),a(\"code\",[e._v(\"let\")]),e._v(\"、\"),a(\"code\",[e._v(\"var\")]),e._v(\"和\"),a(\"code\",[e._v(\"const\")]),e._v(\"创建变量有什么区别？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"用\"),a(\"code\",[e._v(\"var\")]),e._v(\"声明的变量的作用域是它当前的执行上下文，它可以是嵌套的函数，也可以是声明在任何函数外的变量。\"),a(\"code\",[e._v(\"let\")]),e._v(\"和\"),a(\"code\",[e._v(\"const\")]),e._v(\"是块级作用域，意味着它们只能在最近的一组花括号（\"),a(\"code\",[e._v(\"function\")]),e._v(\"、\"),a(\"code\",[e._v(\"if-else\")]),e._v(\" 代码块或 \"),a(\"code\",[e._v(\"for\")]),e._v(\" 循环中）中访问。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction foo() {\\n  // 所有变量在函数中都可访问\\n  var bar = 'bar';\\n  let baz = 'baz';\\n  const qux = 'qux';\\n\\n  console.log(bar); // bar\\n  console.log(baz); // baz\\n  console.log(qux); // qux\\n}\\n\\nconsole.log(bar); // ReferenceError: bar is not defined\\nconsole.log(baz); // ReferenceError: baz is not defined\\nconsole.log(qux); // ReferenceError: qux is not defined\\n\\nif (true) {\\n  var bar = 'bar';\\n  let baz = 'baz';\\n  const qux = 'qux';\\n}\\n\\n// 用 var 声明的变量在函数作用域上都可访问\\nconsole.log(bar); // bar\\n\\n// let 和 const 定义的变量在它们被定义的语句块之外不可访问\\nconsole.log(baz); // ReferenceError: baz is not defined\\nconsole.log(qux); // ReferenceError: qux is not defined\\n\\nvar会使变量提升，这意味着变量可以在声明之前使用。let和const不会使变量提升，提前使用会报错。\\n\\nconsole.log(foo); // undefined\\n\\nvar foo = 'foo';\\n\\nconsole.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization\\n\\nlet baz = 'baz';\\n\\nconsole.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization\\n\\nconst bar = 'bar';\\n\\n用var重复声明不会报错，但let和const会。\\n\\nvar foo = 'foo';\\nvar foo = 'bar';\\nconsole.log(foo); // \\\"bar\\\"\\n\\nlet baz = 'baz';\\nlet baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared\\n\\nlet和const的区别在于：let允许多次赋值，而const只允许一次。\\n\\n// 这样不会报错。\\nlet foo = 'foo';\\nfoo = 'bar';\\n\\n// 这样会报错。\\nconst baz = 'baz';\\nbaz = 'qux';\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_41-高阶函数-（higher-order）-的定义是什么？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_41-高阶函数-（higher-order）-的定义是什么？\"}},[e._v(\"#\")]),e._v(\" 41.高阶函数 \"),a(\"code\",[e._v(\"（higher-order）\")]),e._v(\" 的定义是什么？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"高阶函数是将一个或多个函数作为参数的函数，它用于数据处理，也可能将函数作为返回结果。高阶函数是为了抽象一些重复执行的操作。一个典型的例子是\"),a(\"code\",[e._v(\"map\")]),e._v(\"，它将一个数组和一个函数作为参数。map使用这个函数来转换数组中的每个元素，并返回一个包含转换后元素的新数组。\"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 中的其他常见示例是 \"),a(\"code\",[e._v(\"forEach\")]),e._v(\"、\"),a(\"code\",[e._v(\"filter\")]),e._v(\"和\"),a(\"code\",[e._v(\"reduce\")]),e._v(\"。高阶函数不仅需要操作数组的时候会用到，还有许多函数返回新函数的用例。\"),a(\"code\",[e._v(\"Function.prototype.bind\")]),e._v(\"就是一个例子。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nMap 示例：\\n\\n假设我们有一个由名字组成的数组，我们需要将每个字符转换为大写字母。\\n\\nconst names = ['irish', 'daisy', 'anna'];\\n不使用高阶函数的方法是这样：\\n\\nconst transformNamesToUppercase = function(names) {\\n  const results = [];\\n  for (let i = 0; i < names.length; i++) {\\n    results.push(names[i].toUpperCase());\\n  }\\n  return results;\\n};\\n\\ntransformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']\\n\\n使用.map(transformerFn)使代码更简明\\n\\nconst transformNamesToUppercase = function(names) {\\n  return names.map(name => name.toUpperCase());\\n};\\ntransformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_42-请给出一个解构-（destructuring）-对象或数组的例子。\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_42-请给出一个解构-（destructuring）-对象或数组的例子。\"}},[e._v(\"#\")]),e._v(\" 42.请给出一个解构 \"),a(\"code\",[e._v(\"（destructuring）\")]),e._v(\" 对象或数组的例子。\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"解构是 \"),a(\"code\",[e._v(\"ES6\")]),e._v(\" 中新功能，它提供了一种简洁方便的方法来提取对象或数组的值，并将它们放入不同的变量中。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\n数组解构\\n\\n// 变量赋值\\nconst foo = ['one', 'two', 'three'];\\n\\nconst [one, two, three] = foo;\\nconsole.log(one); // \\\"one\\\"\\nconsole.log(two); // \\\"two\\\"\\nconsole.log(three); // \\\"three\\\"\\n// 变量交换\\nlet a = 1;\\nlet b = 3;\\n\\n[a, b] = [b, a];\\nconsole.log(a); // 3\\nconsole.log(b); // 1\\n对象解构\\n\\n// 变量赋值\\nconst o = { p: 42, q: true };\\nconst { p, q } = o;\\n\\nconsole.log(p); // 42\\nconsole.log(q); // true\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_43-es6-的模板字符串为生成字符串提供了很大的灵活性，你可以举个例子吗？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_43-es6-的模板字符串为生成字符串提供了很大的灵活性，你可以举个例子吗？\"}},[e._v(\"#\")]),e._v(\" 43.\"),a(\"code\",[e._v(\"ES6\")]),e._v(\" 的模板字符串为生成字符串提供了很大的灵活性，你可以举个例子吗？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"模板字面量 \"),a(\"code\",[e._v(\"（Template literals）\")]),e._v(\"  是允许嵌入表达式的字符串字面量。你可以使用多行字符串和字符串插值功能。\")]),e._v(\" \"),a(\"p\",[e._v(\"语法\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v('\\n`string text`\\n`string text line 1 string text line 2`\\n`string text ${expression} string text`;\\ntag`string text ${expression} string text`;\\n\\n示例\\nconsole.log(`string text line 1 string text line 2`);\\n// \"string text line 1 string text line 2\"\\n\\nvar a = 5;\\nvar b = 10;\\nconsole.log(`Fifteen is ${a + b} and\\\\nnot ${2 * a + b}.`);\\n// \"Fifteen is 15 and\\\\nnot 20.\"\\n\\n//show函数采用rest参数的写法如下：\\n\\nlet name = \\'张三\\',\\n  age = 20,\\n  message = show`我来给大家介绍:${name}的年龄是${age}.`;\\n\\nfunction show(stringArr, ...values) {\\n  let output = \\'\\';\\n\\n  let index = 0;\\n\\n  for (; index < values.length; index++) {\\n    output += stringArr[index] + values[index];\\n  }\\n\\n  output += stringArr[index];\\n\\n  return output;\\n}\\n\\nmessage; //\"我来给大家介绍:张三的年龄是20.\"\\n\\n')])])]),a(\"h3\",{attrs:{id:\"_44-你能举出一个柯里化函数（curry-function）的例子吗？它有哪些好处？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_44-你能举出一个柯里化函数（curry-function）的例子吗？它有哪些好处？\"}},[e._v(\"#\")]),e._v(\" 44.你能举出一个柯里化函数（curry function）的例子吗？它有哪些好处？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"柯里化 \"),a(\"code\",[e._v(\"（currying）\")]),e._v(\" 是一种模式，其中具有多个参数的函数被分解为多个函数，当被串联调用时，将一次一个地累积所有需要的参数。这种技术帮助编写函数式风格的代码，使代码更易读、紧凑。值得注意的是，对于需要被 \"),a(\"code\",[e._v(\"curry\")]),e._v(\"  的函数，它需要从一个函数开始，然后分解成一系列函数，每个函数都需要一个参数。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction curry(fn) {\\n  if (fn.length === 0) {\\n    return fn;\\n  }\\n\\n  function _curried(depth, args) {\\n    return function(newArgument) {\\n      if (depth - 1 === 0) {\\n        return fn(...args, newArgument);\\n      }\\n      return _curried(depth - 1, [...args, newArgument]);\\n    };\\n  }\\n\\n  return _curried(fn.length, []);\\n}\\n\\nfunction add(a, b) {\\n  return a + b;\\n}\\n\\nvar curriedAdd = curry(add);\\nvar addFive = curriedAdd(5);\\n\\nvar result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_45-使用扩展运算符（spread）的好处是什么，它与使用剩余参数语句（rest）有什么区别？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_45-使用扩展运算符（spread）的好处是什么，它与使用剩余参数语句（rest）有什么区别？\"}},[e._v(\"#\")]),e._v(\" 45.使用扩展运算符（spread）的好处是什么，它与使用剩余参数语句（rest）有什么区别？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"在函数泛型编码时，\"),a(\"code\",[e._v(\"ES6\")]),e._v(\" 的扩展运算符非常有用，因为我们可以轻松创建数组和对象的拷贝，而无需使用 \"),a(\"code\",[e._v(\"Object.create\")]),e._v(\"、\"),a(\"code\",[e._v(\"slice\")]),e._v(\" 或其他函数库。这个语言特性在 \"),a(\"code\",[e._v(\"Redux\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"rx.js\")]),e._v(\" 的项目中经常用到。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction putDookieInAnyArray(arr) {\\n  return [...arr, 'dookie'];\\n}\\n\\nconst result = putDookieInAnyArray(['I', 'really', \\\"don't\\\", 'like']); // [\\\"I\\\", \\\"really\\\", \\\"don't\\\", \\\"like\\\", \\\"dookie\\\"]\\n\\nconst person = {\\n  name: 'Todd',\\n  age: 29,\\n};\\n\\nconst copyOfTodd = { ...person };\\n\\n\")])])]),a(\"p\",[a(\"code\",[e._v(\"ES6\")]),e._v(\" 的剩余参数语句提供了一个简写，允许我们将不定数量的参数表示为一个数组。它就像是扩展运算符语法的反面，将数据收集到数组中，而不是解构数组。剩余参数语句在函数参数、数组和对象的解构赋值中有很大作用。\")]),e._v(\" \"),a(\"div\",{staticClass:\"language- extra-class\"},[a(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[a(\"code\",[e._v(\"\\nfunction addFiveToABunchOfNumbers(...numbers) {\\n  return numbers.map(x => x + 5);\\n}\\n\\nconst result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]\\n\\nconst [a, b, ...rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]\\n\\nconst { e, f, ...others } = {\\n  e: 1,\\n  f: 2,\\n  g: 3,\\n  h: 4,\\n}; // e: 1, f: 2, others: { g: 3, h: 4 }\\n\\n\")])])]),a(\"h3\",{attrs:{id:\"_46-如何在文件之间共用代码？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_46-如何在文件之间共用代码？\"}},[e._v(\"#\")]),e._v(\" 46.如何在文件之间共用代码？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"这取决于执行 \"),a(\"code\",[e._v(\"JavaScript\")]),e._v(\" 的环境。\")]),e._v(\" \"),a(\"p\",[e._v(\"在客户端（浏览器环境）上，只要变量或函数在全局作用域 \"),a(\"code\",[e._v(\"（window）\")]),e._v(\" 中声明，所有脚本都可以引用它们。或者，通过 \"),a(\"code\",[e._v(\"RequireJS\")]),e._v(\"  采用异步模块定义 \"),a(\"code\",[e._v(\"（AMD）\")]),e._v(\" 以获得更多模块化方法。\")]),e._v(\" \"),a(\"p\",[e._v(\"在服务器 \"),a(\"code\",[e._v(\"（Node.js）\")]),e._v(\" 上，常用的方法是使用 \"),a(\"code\",[e._v(\"CommonJS\")]),e._v(\"。每个文件都被视为一个模块，可以通过将它们附加到\"),a(\"code\",[e._v(\"module.exports\")]),e._v(\"对象来导出变量和函数。\")]),e._v(\" \"),a(\"p\",[a(\"code\",[e._v(\"ES2015\")]),e._v(\" 定义了一个模块语法，旨在替换 \"),a(\"code\",[e._v(\"AMD\")]),e._v(\" 和 \"),a(\"code\",[e._v(\"CommonJS\")]),e._v(\"。 这最终将在浏览器和 \"),a(\"code\",[e._v(\"Node\")]),e._v(\" 环境中得到支持。\")]),e._v(\" \"),a(\"h3\",{attrs:{id:\"_47-什么情况下会用到静态类成员？\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_47-什么情况下会用到静态类成员？\"}},[e._v(\"#\")]),e._v(\" 47.什么情况下会用到静态类成员？\")]),e._v(\" \"),a(\"hr\"),e._v(\" \"),a(\"p\",[e._v(\"静态类成员（属性或方法）不绑定到某个类的特定实例，不管哪个实例引用它，都具有相同的值。静态属性通常是配置变量，而静态方法通常是纯粹的实用函数，不依赖于实例的状态。\")]),e._v(\" \"),a(\"blockquote\",[a(\"p\",[e._v(\"文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞👍和关注，😀。\")])])])}),[],!1,null,null,null);n.default=t.exports}}]);","extractedComments":[]}