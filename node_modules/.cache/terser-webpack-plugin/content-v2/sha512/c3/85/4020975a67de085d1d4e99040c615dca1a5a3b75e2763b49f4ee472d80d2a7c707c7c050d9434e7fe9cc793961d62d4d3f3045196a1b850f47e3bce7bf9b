{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{346:function(h,a,t){\"use strict\";t.r(a);var s=t(28),n=Object(s.a)({},(function(){var h=this,a=h.$createElement,t=h._self._c||a;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":h.$parent.slotKey}},[t(\"h3\",{attrs:{id:\"webpack几种hash的区别\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#webpack几种hash的区别\"}},[h._v(\"#\")]),h._v(\" webpack几种hash的区别\")]),h._v(\" \"),t(\"p\",[h._v(\"静态资源缓存是前端优化的几种方式之一， 如果文件名保持不变的话，在命中强缓存的时候会导致文件不是最新的，所以我们需要使用hash值来保证我们每次用到的都是最新的文件\")]),h._v(\" \"),t(\"h3\",{attrs:{id:\"hash\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#hash\"}},[h._v(\"#\")]),h._v(\" hash\")]),h._v(\" \"),t(\"p\",[h._v(\"如果都使用hash的话，因为这是工程级别的，即每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效\")]),h._v(\" \"),t(\"h3\",{attrs:{id:\"chunkhash\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#chunkhash\"}},[h._v(\"#\")]),h._v(\" chunkhash\")]),h._v(\" \"),t(\"p\",[h._v(\"chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着我们采用chunkhash的方式生成哈希值，那么只要我们不改动公共库的代码，就可以保证其哈希值不会受影响。并且webpack4中支持了异步import功能，固，chunkhash也作用于此。\")]),h._v(\" \"),t(\"h3\",{attrs:{id:\"contenthash\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#contenthash\"}},[h._v(\"#\")]),h._v(\" contenthash\")]),h._v(\" \"),t(\"p\",[h._v(\"contenthash是针对文件内容级别的，只有你自己模块的内容变了，那么hash值才改变，所以我们可以通过contenthash解决上诉问题。\")])])}),[],!1,null,null,null);a.default=n.exports}}]);","extractedComments":[]}